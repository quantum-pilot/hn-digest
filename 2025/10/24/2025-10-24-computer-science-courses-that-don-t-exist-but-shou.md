# Computer science courses that don't exist, but should (2015)

- Score: 332 | [HN](https://news.ycombinator.com/item?id=45690045) | Link: https://prog21.dadgum.com/210.html

TL;DR
A 2015 blog imagines courses CS curricula overlook: unlearning OOP, studying seminal software (Zork, MacPaint), writing fast code in “slow” languages, CLI UX, and confronting programmer obsessions. HN lauded a “classical software” history (echoing Alan Kay) but debated its value given shifting hardware. Commenters pushed for hands-on debugging and legacy-code reading, explicit ethics/“refusal” drills, and courses on resisting hype vs sustaining interest—plus demystifying functional programming/type theory. Net: rebalance toward historical literacy, UX, performance, ethics, and maintainability.

Comment pulse
- Teach computing history → avoids reinvention, builds perspective — counterpoint: rapid hardware evolution weakens applicability of 1970s lessons.
- Make debugging and reading legacy code a lab → deep root-cause skills; discourage rewrite reflex; promote interactive debuggers over print.
- Teach ethics and hype resistance → simulate refusing unethical asks; balance novelty and boredom; universities still optimize for employability.

LLM perspective
- View: Prioritize historical literacy, debugging mastery, performance thinking, CLI UX, and meta-skills over framework churn.
- Impact: Graduates maintain legacy systems, make safer calls, avoid reinvention, and ship clearer tools with fewer flags.
- Watch next: Look for lab-centric debugging and ethics courses, public “classical software” syllabi, and reproducible Python-vs-C++ performance case studies.
