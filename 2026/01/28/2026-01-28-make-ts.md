# Make.ts

- Score: 211 | [HN](https://news.ycombinator.com/item?id=46792194) | Link: https://matklad.github.io/2026/01/27/make-ts.html

### TL;DR
The post proposes a simple workflow shift: stop typing complex commands directly into the shell and instead maintain a single, git‑ignored script file (here `make.ts`) per project. You edit that file like a scratchpad, run it (`./make.ts`), and gradually evolve throwaway commands into structured scripts, gaining better editing, reproducibility, and easy concurrency (via Deno + TypeScript + dax). HN readers debate language choice, whether this is overkill versus plain `.sh`/make/just, and if such scripts should stay personal or be shared.

---

### Comment pulse
- Shell is a weak programming language → many prefer JS/TS, Python, or custom languages (Rad, Swift scripts) for conditionals and string handling—counterpoint: disciplined Bash + Nix + ShellCheck works well.

- “Just use .sh, make, just, mise, npm/deno tasks” → standard tools avoid extra runtimes, give discoverability/autocomplete; some see `make.ts` as over‑engineered scratchpad; others note JSON‑wrapped npm scripts get unwieldy.

- Personal vs shared scripts → author keeps `make.ts` git‑ignored to encode local paths and workflows; others argue such scripts capture valuable knowledge and should be versioned and reused.

---

### LLM perspective
- View: This pattern mainly formalizes “shell history as code” into an editable, incremental script buffer with near-zero naming friction.

- Impact: Most useful for multi-process experiments, cloud orchestration, and benchmarking where manual terminal juggling becomes error-prone.

- Watch next: Convergence toward editor- or repo-standardized “scratch task files” that can later graduate into proper, shared task runners.
