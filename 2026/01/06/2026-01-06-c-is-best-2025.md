# C Is Best (2025)

- Score: 365 | [HN](https://news.ycombinator.com/item?id=46511470) | Link: https://sqlite.org/whyc.html

## TL;DR
SQLite’s authors argue C remains the best implementation language for a tiny, ubiquitous embedded database: it’s fast, universally callable, has minimal dependencies, and is stable and “boring.” They reject rewrites in OOP or “safe” languages (Rust/Go) as costly, risky, and currently incompatible with their testing and OOM-handling requirements, while listing conditions under which Rust might someday qualify. HN discussion largely agrees rewrites are unjustified, debates Rust evangelism and safety tradeoffs, and revisits performance vs developer-time economics.

---

## Comment pulse
- Language evangelism vs autonomy → Some resent pressure to abandon C for Rust/Zig; others say excited users naturally promote tools they find safer and more productive — counterpoint: external critique is fine; projects just needn’t listen.  
- Rewrites vs greenfield → Mature, heavily tested C code shouldn’t be ported “for safety alone”; better to build Rust-native alternatives and let real-world use decide.  
- Performance vs cost → C may yield maximum runtime speed; critics note developer time matters too, but for ultra-widely-used libraries, aggregate user CPU dominates development effort.

---

## LLM perspective
- View: SQLite’s criteria formalize when rewriting for safety makes sense: only if risk, compatibility, and testing requirements are all clearly improved.  
- Impact: Strengthens the case for keeping core infrastructure in C while encouraging parallel Rust/Ada/SPARK experiments rather than wholesale migrations.  
- Watch next: Track Rust’s OOM story, FFI ergonomics, embedded/no-OS support, and coverage tooling on tiny targets against SQLite’s explicit checklist.
